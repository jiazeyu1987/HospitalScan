# 行政区划数据源设计与实现方案

**作者：** MiniMax Agent  
**版本：** v1.0  
**日期：** 2025-11-18  
**项目：** 全国医院官网扫描与招投标监控系统

---

## 📍 一、数据源选择与评估

### 1.1 可用数据源对比

| 数据源 | 类型 | 更新频率 | 费用 | 数据质量 | 推荐度 |
|--------|------|----------|------|----------|--------|
| **国家统计局** | 官方 | 年更新 | 免费 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **GeoJSON.cn** | 第三方 | 月更新 | 部分收费 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **GitHub开源项目** | 社区 | 不定期 | 免费 | ⭐⭐⭐ | ⭐⭐⭐ |
| **民政部** | 官方 | 不定期 | 免费 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

### 1.2 最终数据源策略
采用**多数据源融合**策略：
1. **主数据源**：GitHub开源项目 (免费、完整结构)
2. **验证数据源**：官方行政区划信息 (权威性)
3. **补充数据源**：GeoJSON.cn (地理坐标)

---

## 📁 二、数据结构设计

### 2.1 JSON数据结构标准

基于收集的数据源，设计统一的数据结构：

```json
{
  "version": "2024.1",
  "update_date": "2024-06-07",
  "total_regions": 3465,
  "hierarchy": {
    "country": {
      "name": "中华人民共和国",
      "code": "CN",
      "level": 0
    },
    "provinces": [
      {
        "id": 1,
        "name": "北京市",
        "code": "110000",
        "full_name": "中华人民共和国北京市",
        "level": 1,
        "parent_id": 0,
        "children": [
          {
            "id": 2,
            "name": "东城区",
            "code": "110101",
            "full_name": "北京市东城区",
            "level": 2,
            "parent_id": 1,
            "children": [...]
          }
        ]
      }
    ]
  }
}
```

### 2.2 字段映射表

| 数据库字段 | JSON字段 | 类型 | 说明 |
|------------|----------|------|------|
| `id` | `id` | INTEGER | 地区ID |
| `name` | `name` | VARCHAR | 地区名称 |
| `code` | `code` | VARCHAR | 行政区划代码 |
| `level` | `level` | ENUM | 地区层级 |
| `parent_id` | `parent_id` | INTEGER | 父级地区ID |
| `sort_order` | `order` | INTEGER | 排序顺序 |

### 2.3 地区层级定义

```python
class RegionLevel(Enum):
    """地区层级定义"""
    COUNTRY = 0      # 国家
    PROVINCE = 1     # 省/自治区/直辖市/特别行政区  
    CITY = 2         # 地级市/地区/盟/自治州
    COUNTY = 3       # 县/区/县级市/旗
    TOWNSHIP = 4     # 乡/镇/街道
    VILLAGE = 5      # 村/社区
```

---

## 💾 三、数据导入模块设计

### 3.1 核心导入服务

```python
# region_importer.py
import json
import sqlite3
import logging
from typing import List, Dict, Optional
from pathlib import Path

class RegionImporter:
    """行政区划数据导入器"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.logger = logging.getLogger(__name__)
        self.import_stats = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'duplicates': 0
        }
    
    def import_from_json(self, json_file: str, replace_existing: bool = False) -> Dict:
        """从JSON文件导入数据"""
        
        try:
            # 1. 读取JSON数据
            with open(json_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # 2. 验证数据格式
            self._validate_json_structure(data)
            
            # 3. 连接数据库
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            try:
                # 4. 准备导入
                if replace_existing:
                    cursor.execute("DELETE FROM regions")
                    self.logger.info("已清空现有地区数据")
                
                # 5. 批量插入数据
                regions_to_import = self._flatten_hierarchy(data['hierarchy'])
                self.import_stats['total'] = len(regions_to_import)
                
                # 批量插入优化
                self._batch_insert_regions(cursor, regions_to_import)
                
                # 6. 提交事务
                conn.commit()
                self.import_stats['success'] = len(regions_to_import)
                
                self.logger.info(f"导入完成：{self.import_stats}")
                
                return {
                    'status': 'success',
                    'stats': self.import_stats.copy(),
                    'message': f'成功导入 {self.import_stats["success"]} 条地区数据'
                }
                
            except Exception as e:
                conn.rollback()
                raise e
            finally:
                conn.close()
                
        except Exception as e:
            self.import_stats['failed'] += 1
            self.logger.error(f"导入失败：{str(e)}")
            return {
                'status': 'failed',
                'error': str(e),
                'stats': self.import_stats.copy()
            }
    
    def _validate_json_structure(self, data: Dict) -> None:
        """验证JSON数据结构"""
        required_keys = ['version', 'update_date', 'hierarchy']
        for key in required_keys:
            if key not in data:
                raise ValueError(f"缺少必需字段：{key}")
        
        if 'provinces' not in data['hierarchy']:
            raise ValueError("JSON数据缺少 provinces 字段")
    
    def _flatten_hierarchy(self, hierarchy: Dict) -> List[Dict]:
        """将层级结构扁平化为列表"""
        regions = []
        
        # 添加国家
        country = hierarchy.get('country')
        if country:
            regions.append({
                'id': country.get('id', 0),
                'name': country['name'],
                'code': country['code'],
                'level': country['level'],
                'parent_id': 0,
                'sort_order': 0
            })
        
        # 递归处理省份及其子级
        for province in hierarchy.get('provinces', []):
            regions.extend(self._process_region_recursive(province))
        
        return regions
    
    def _process_region_recursive(self, region: Dict, parent_id: int = None) -> List[Dict]:
        """递归处理地区数据"""
        result = []
        
        # 处理当前地区
        region_data = {
            'id': region.get('id'),
            'name': region['name'],
            'code': region['code'],
            'level': region['level'],
            'parent_id': parent_id or 0,
            'sort_order': 0
        }
        result.append(region_data)
        
        # 递归处理子级
        for child in region.get('children', []):
            result.extend(self._process_region_recursive(child, region['id']))
        
        return result
    
    def _batch_insert_regions(self, cursor, regions: List[Dict]) -> None:
        """批量插入地区数据"""
        sql = """
        INSERT OR REPLACE INTO regions 
        (id, name, code, level, parent_id, sort_order, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        """
        
        batch_size = 1000
        for i in range(0, len(regions), batch_size):
            batch = regions[i:i + batch_size]
            cursor.executemany(sql, [
                (r['id'], r['name'], r['code'], r['level'], r['parent_id'], r['sort_order'])
                for r in batch
            ])
            self.logger.info(f"已处理 {i + len(batch)} / {len(regions)} 条记录")

    def get_import_status(self) -> Dict:
        """获取导入状态统计"""
        return self.import_stats.copy()
```

### 3.2 数据验证器

```python
# region_validator.py
from typing import List, Dict, Set
import re

class RegionDataValidator:
    """行政区划数据验证器"""
    
    @staticmethod
    def validate_region_code(code: str) -> bool:
        """验证行政区划代码格式"""
        # 6位数字代码 (省2位 + 市2位 + 区县2位)
        if len(code) == 6 and code.isdigit():
            return True
        # 其他格式验证逻辑
        return False
    
    @staticmethod
    def check_hierarchy_consistency(regions: List[Dict]) -> List[str]:
        """检查层级关系一致性"""
        errors = []
        region_map = {r['id']: r for r in regions}
        
        for region in regions:
            # 检查父级是否存在
            if region['parent_id'] != 0:
                if region['parent_id'] not in region_map:
                    errors.append(f"地区 {region['name']} 的父级 {region['parent_id']} 不存在")
            
            # 检查代码层级是否正确
            if region['level'] > 0:
                expected_prefix = region_map[region['parent_id']]['code'][:2]
                actual_prefix = region['code'][:2]
                if expected_prefix != actual_prefix:
                    errors.append(f"地区 {region['name']} 代码前缀不匹配")
        
        # 检查代码唯一性
        codes = [r['code'] for r in regions]
        if len(codes) != len(set(codes)):
            errors.append("存在重复的行政区划代码")
        
        return errors
```

### 3.3 示例数据文件

创建符合系统要求的示例JSON数据：

```json
{
  "version": "2024.1",
  "update_date": "2024-11-18",
  "total_regions": 3465,
  "source": "GitHub开源项目 + 官方数据验证",
  "hierarchy": {
    "country": {
      "id": 0,
      "name": "中华人民共和国",
      "code": "CN",
      "full_name": "中华人民共和国",
      "level": 0,
      "parent_id": 0,
      "children": []
    },
    "provinces": [
      {
        "id": 1,
        "name": "北京市",
        "code": "110000",
        "full_name": "中华人民共和国北京市",
        "level": 1,
        "parent_id": 0,
        "children": [
          {
            "id": 101,
            "name": "东城区",
            "code": "110101",
            "full_name": "北京市东城区",
            "level": 2,
            "parent_id": 1,
            "children": []
          },
          {
            "id": 102,
            "name": "西城区", 
            "code": "110102",
            "full_name": "北京市西城区",
            "level": 2,
            "parent_id": 1,
            "children": []
          },
          {
            "id": 103,
            "name": "朝阳区",
            "code": "110105",
            "full_name": "北京市朝阳区",
            "level": 2,
            "parent_id": 1,
            "children": []
          }
        ]
      },
      {
        "id": 2,
        "name": "上海市",
        "code": "310000",
        "full_name": "中华人民共和国上海市",
        "level": 1,
        "parent_id": 0,
        "children": [
          {
            "id": 201,
            "name": "黄浦区",
            "code": "310101",
            "full_name": "上海市黄浦区",
            "level": 2,
            "parent_id": 2,
            "children": []
          },
          {
            "id": 202,
            "name": "徐汇区",
            "code": "310104",
            "full_name": "上海市徐汇区",
            "level": 2,
            "parent_id": 2,
            "children": []
          }
        ]
      },
      {
        "id": 3,
        "name": "河北省",
        "code": "130000",
        "full_name": "中华人民共和国河北省",
        "level": 1,
        "parent_id": 0,
        "children": [
          {
            "id": 301,
            "name": "石家庄市",
            "code": "130100",
            "full_name": "河北省石家庄市",
            "level": 2,
            "parent_id": 3,
            "children": [
              {
                "id": 30101,
                "name": "长安区",
                "code": "130102",
                "full_name": "河北省石家庄市长安区",
                "level": 3,
                "parent_id": 301,
                "children": []
              },
              {
                "id": 30102,
                "name": "桥西区",
                "code": "130104",
                "full_name": "河北省石家庄市桥西区",
                "level": 3,
                "parent_id": 301,
                "children": []
              }
            ]
          }
        ]
      }
    ]
  }
}
```

---

## 🔄 四、地区级联查询接口

### 4.1 数据库查询服务

```python
# region_service.py
import sqlite3
from typing import List, Dict, Optional
from dataclasses import dataclass

@dataclass
class RegionTreeNode:
    """地区树节点"""
    id: int
    name: str
    code: str
    level: int
    parent_id: int
    children: List['RegionTreeNode']
    hospital_count: int = 0

class RegionService:
    """地区管理服务"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    def get_regions_tree(self, root_level: int = 0) -> List[RegionTreeNode]:
        """获取地区树形结构"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        try:
            # 获取所有地区
            cursor.execute("""
                SELECT r.*, COUNT(h.id) as hospital_count
                FROM regions r
                LEFT JOIN hospitals h ON r.id = h.region_id
                WHERE r.level >= ?
                GROUP BY r.id
                ORDER BY r.level, r.sort_order, r.name
            """, (root_level,))
            
            regions_data = cursor.fetchall()
            
            # 构建树形结构
            region_map = {}
            for row in regions_data:
                region = RegionTreeNode(
                    id=row['id'],
                    name=row['name'],
                    code=row['code'],
                    level=row['level'],
                    parent_id=row['parent_id'],
                    children=[],
                    hospital_count=row['hospital_count']
                )
                region_map[region.id] = region
            
            # 构建父子关系
            root_nodes = []
            for region in region_map.values():
                if region.parent_id in region_map:
                    region_map[region.parent_id].children.append(region)
                else:
                    root_nodes.append(region)
            
            return root_nodes
            
        finally:
            conn.close()
    
    def search_regions(self, keyword: str, max_results: int = 50) -> List[Dict]:
        """搜索地区"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        try:
            cursor.execute("""
                SELECT r.*, p.name as parent_name
                FROM regions r
                LEFT JOIN regions p ON r.parent_id = p.id
                WHERE r.name LIKE ? OR r.code LIKE ?
                ORDER BY r.level, r.name
                LIMIT ?
            """, (f'%{keyword}%', f'%{keyword}%', max_results))
            
            return [dict(row) for row in cursor.fetchall()]
            
        finally:
            conn.close()
    
    def get_region_by_id(self, region_id: int) -> Optional[Dict]:
        """根据ID获取地区信息"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        try:
            cursor.execute("""
                SELECT r.*, p.name as parent_name, COUNT(h.id) as hospital_count
                FROM regions r
                LEFT JOIN regions p ON r.parent_id = p.id
                LEFT JOIN hospitals h ON r.id = h.region_id
                WHERE r.id = ?
                GROUP BY r.id
            """, (region_id,))
            
            row = cursor.fetchone()
            return dict(row) if row else None
            
        finally:
            conn.close()
    
    def get_child_regions(self, parent_id: int) -> List[Dict]:
        """获取子级地区列表"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        try:
            cursor.execute("""
                SELECT r.*, COUNT(h.id) as hospital_count
                FROM regions r
                LEFT JOIN hospitals h ON r.id = h.region_id
                WHERE r.parent_id = ?
                ORDER BY r.name
            """, (parent_id,))
            
            return [dict(row) for row in cursor.fetchall()]
            
        finally:
            conn.close()
    
    def get_province_city_count(self) -> Dict[str, int]:
        """获取各省份城市数量统计"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute("""
                SELECT p.name as province, COUNT(DISTINCT c.id) as city_count
                FROM regions p
                LEFT JOIN regions c ON c.parent_id = p.id AND c.level = 2
                WHERE p.level = 1
                GROUP BY p.id, p.name
                ORDER BY city_count DESC
            """)
            
            return {row[0]: row[1] for row in cursor.fetchall()}
            
        finally:
            conn.close()
```

### 4.2 地区统计视图

```sql
-- 地区统计视图
CREATE VIEW v_region_statistics AS
SELECT 
    r.id,
    r.name,
    r.code,
    r.level,
    r.parent_id,
    p.name as parent_name,
    COUNT(DISTINCT h.id) as hospital_count,
    COUNT(DISTINCT t.id) as tender_count,
    COUNT(DISTINCT CASE WHEN h.verified = 1 THEN h.id END) as verified_hospital_count
FROM regions r
LEFT JOIN regions p ON r.parent_id = p.id
LEFT JOIN hospitals h ON r.id = h.region_id
LEFT JOIN tender_records t ON h.id = t.hospital_id
GROUP BY r.id, r.name, r.code, r.level, r.parent_id, p.name;

-- 省级统计
CREATE VIEW v_province_stats AS
SELECT 
    r.id,
    r.name as province_name,
    r.code as province_code,
    COUNT(DISTINCT city.id) as city_count,
    COUNT(DISTINCT county.id) as county_count,
    COUNT(DISTINCT h.id) as hospital_count
FROM regions r
LEFT JOIN regions city ON city.parent_id = r.id AND city.level = 2
LEFT JOIN regions county ON county.parent_id = city.id AND county.level = 3
LEFT JOIN hospitals h ON county.id = h.region_id
WHERE r.level = 1
GROUP BY r.id, r.name, r.code;
```

---

## 🚀 五、部署和使用指南

### 5.1 快速开始脚本

```bash
#!/bin/bash
# setup_regions.sh

echo "正在初始化行政区划数据..."

# 1. 创建数据目录
mkdir -p /workspace/data

# 2. 创建数据库表
python create_tables.py

# 3. 导入示例数据
python import_regions.py --json /workspace/data/regions_sample.json --replace

# 4. 验证数据
python validate_regions.py

# 5. 生成统计报告
python generate_region_stats.py

echo "行政区划数据初始化完成！"
```

### 5.2 数据导入命令

```bash
# 完整数据导入
python region_importer.py \
    --db-path /workspace/data/hospital_monitor.db \
    --json /workspace/data/regions_full.json \
    --replace \
    --verbose

# 增量更新
python region_importer.py \
    --db-path /workspace/data/hospital_monitor.db \
    --json /workspace/data/regions_update.json \
    --merge

# 仅验证数据
python region_importer.py \
    --json /workspace/data/regions.json \
    --validate-only
```

### 5.3 数据源更新机制

```python
# data_update_manager.py
import requests
from datetime import datetime
import hashlib

class DataUpdateManager:
    """数据源更新管理器"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.sources = config['data_sources']
        self.backup_dir = config['backup_dir']
    
    def check_for_updates(self) -> List[Dict]:
        """检查数据源更新"""
        updates = []
        
        for source in self.sources:
            try:
                response = requests.get(source['url'], timeout=10)
                if response.status_code == 200:
                    current_hash = hashlib.md5(response.content).hexdigest()
                    
                    if source.get('last_hash') != current_hash:
                        updates.append({
                            'source': source['name'],
                            'url': source['url'],
                            'new_hash': current_hash,
                            'size': len(response.content),
                            'timestamp': datetime.now()
                        })
            except Exception as e:
                print(f"检查数据源 {source['name']} 失败: {e}")
        
        return updates
    
    def download_and_import_updates(self, updates: List[Dict]) -> Dict:
        """下载并导入更新"""
        results = []
        
        for update in updates:
            try:
                # 下载数据
                response = requests.get(update['url'], timeout=30)
                
                # 保存到临时文件
                temp_file = f"/tmp/{update['source']}_{update['timestamp'].strftime('%Y%m%d_%H%M%S')}.json"
                with open(temp_file, 'w', encoding='utf-8') as f:
                    f.write(response.text)
                
                # 导入数据
                importer = RegionImporter(self.config['db_path'])
                result = importer.import_from_json(temp_file, replace_existing=False)
                
                results.append({
                    'source': update['source'],
                    'status': result['status'],
                    'stats': result['stats']
                })
                
            except Exception as e:
                results.append({
                    'source': update['source'],
                    'status': 'failed',
                    'error': str(e)
                })
        
        return results
```

---

## 📊 六、数据质量保证

### 6.1 质量检查脚本

```python
# data_quality_checker.py
class DataQualityChecker:
    """数据质量检查器"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    def run_all_checks(self) -> Dict[str, any]:
        """运行所有数据质量检查"""
        results = {
            'timestamp': datetime.now(),
            'checks': {}
        }
        
        results['checks']['missing_codes'] = self.check_missing_codes()
        results['checks']['orphan_regions'] = self.check_orphan_regions()
        results['checks']['duplicate_codes'] = self.check_duplicate_codes()
        results['checks']['hierarchy_consistency'] = self.check_hierarchy_consistency()
        results['checks']['statistical_anomaly'] = self.check_statistical_anomaly()
        
        return results
    
    def check_missing_codes(self) -> Dict:
        """检查缺失的行政区划代码"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute("""
                SELECT name, level, COUNT(*) as count
                FROM regions 
                WHERE code IS NULL OR code = ''
                GROUP BY name, level
            """)
            
            issues = cursor.fetchall()
            return {
                'issue_count': len(issues),
                'issues': [dict(row) for row in issues]
            }
            
        finally:
            conn.close()
    
    def check_orphan_regions(self) -> Dict:
        """检查孤立地区（父级不存在的地区）"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute("""
                SELECT r.name, r.level, r.parent_id
                FROM regions r
                LEFT JOIN regions p ON r.parent_id = p.id
                WHERE r.parent_id != 0 AND p.id IS NULL
            """)
            
            issues = cursor.fetchall()
            return {
                'issue_count': len(issues),
                'issues': [dict(row) for row in issues]
            }
            
        finally:
            conn.close()
```

### 6.2 数据修复建议

基于检查结果，提供自动修复建议：

```python
def generate_repair_suggestions(self, quality_report: Dict) -> List[str]:
    """生成数据修复建议"""
    suggestions = []
    
    # 缺失代码修复
    if quality_report['checks']['missing_codes']['issue_count'] > 0:
        suggestions.append("建议手动补充缺失的行政区划代码")
    
    # 孤立地区修复
    if quality_report['checks']['orphan_regions']['issue_count'] > 0:
        suggestions.append("建议检查并修复父级关系不正确的地区")
    
    # 统计异常修复
    if quality_report['checks']['statistical_anomaly']['issue_count'] > 0:
        suggestions.append("建议检查数据统计异常，验证数据来源")
    
    return suggestions
```

---

## 📈 七、性能优化

### 7.1 索引优化

```sql
-- 针对查询模式优化的索引
CREATE INDEX idx_regions_parent_level ON regions(parent_id, level);
CREATE INDEX idx_regions_code ON regions(code);
CREATE INDEX idx_regions_name_search ON regions(name);

-- 复合查询索引
CREATE INDEX idx_regions_tree_traversal ON regions(level, parent_id, sort_order);

-- 统计查询优化
CREATE INDEX idx_hospitals_region_id ON hospitals(region_id);
CREATE INDEX idx_tenders_hospital_region ON tender_records(hospital_id, publish_date);
```

### 7.2 查询缓存

```python
# region_cache.py
from functools import lru_cache
from typing import List, Dict

class RegionCache:
    """地区数据缓存"""
    
    def __init__(self, region_service: RegionService):
        self.region_service = region_service
        self._tree_cache = None
        self._last_update = None
    
    @lru_cache(maxsize=128)
    def get_region_tree(self, root_level: int = 0) -> List[Dict]:
        """缓存的地区树"""
        return self.region_service.get_regions_tree(root_level)
    
    def invalidate_cache(self):
        """失效缓存"""
        self.get_region_tree.cache_clear()
        self._tree_cache = None
        self._last_update = None
```

---

## 🎯 八、总结

本行政区划数据源设计方案提供了：

1. **多数据源策略** - 免费、权威、可持续的数据获取方案
2. **标准化数据结构** - 统一、易扩展的JSON格式
3. **完整导入流程** - 验证、批量导入、错误处理
4. **高效查询接口** - 树形结构、级联查询、缓存优化
5. **质量保证机制** - 自动检查、修复建议、性能监控
6. **自动更新机制** - 数据源监控、增量更新、备份策略

该方案确保了行政区划数据的准确性、完整性和可用性，为医院招投标监控系统提供可靠的数据基础。

**下一步：** 基于此设计方案，实现具体的代码模块和API接口。